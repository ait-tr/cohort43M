### Lesson 28


### `HashSet`

`HashSet` в Java является частью Java Collections Framework и представляет собой коллекцию, используемую для хранения уникальных элементов. 
Он реализует интерфейс `Set` и использует `HashMap` для хранения элементов.
Это одна из фундаментальных структур данных, доступных в Java Collection Framework. `Set` помогает обеспечить уникальность элементов в коллекции, что делает его идеальным выбором для хранения наборов уникальных значений.

### Основные характеристики `HashSet`:

1. **Уникальность элементов**:
    - `HashSet` хранит только уникальные элементы, то есть не допускает дубликатов.

2. **Быстрый доступ**:
    - `HashSet` обеспечивает быстрый доступ к его элементам. Он использует хеш-код объектов для определения их местоположения в коллекции, что обеспечивает быструю операцию поиска, вставки и удаления.

3. **null значения**:
    - `HashSet` допускает наличие одного `null` элемента.

4. **Неупорядоченность**:
    - `HashSet` не гарантирует сохранение порядка элементов. Элементы располагаются в коллекции в зависимости от их хеш-кодов, что может привести к изменению порядка при добавлении или удалении элементов.

5. **Не синхронизирован**:
    - Как и `HashMap`, `HashSet` не является синхронизированным и не потокобезопасным. Если множество используется несколькими потоками, его следует синхронизировать внешним образом.

### Работа `HashSet`:

- **Хеширование**:
    - При добавлении элемента в `HashSet`, используется его хеш-код для определения места хранения во внутренней структуре `HashMap`. Это позволяет `HashSet` быстро определять, содержит ли он определенный элемент.

- **Коллизии**:
    - Если два элемента имеют одинаковый хеш-код, `HashSet` будет использовать механизм разрешения коллизий для размещения этих элементов.

- **Операции**:
    - Основные операции в `HashSet` включают `add`, `remove`, `contains`, и `size`. Эти операции, как правило, выполняются за постоянное время.

### Примеры использования:

```java
import java.util.HashSet;

public class Example {
    public static void main(String[] args) {
        // Создание HashSet
        HashSet<String> set = new HashSet<>();

        // Добавление элементов
        set.add("Apple");
        set.add("Banana");
        set.add("Orange");

        // Попытка добавить дубликат
        boolean isAdded = set.add("Apple"); // Вернет false, так как "Apple" уже есть в наборе

        // Проверка наличия элемента
        if (set.contains("Banana")) {
            System.out.println("Banana is in the set");
        }

        // Удаление элемента
        set.remove("Orange");

        // Итерация по HashSet
        for (String fruit : set) {
            System.out.println(fruit);
        }
    }
}
```

`HashSet` широко используется в случаях, когда необходимо обеспечить уникальность элементов, и важна скорость доступа к этим элементам. Он особенно полезен в задачах, связанных с наборами данных, где порядок элементов не имеет значения.

### Основные характеристики `Set`:

- **Уникальность:** `Set` гарантирует, что в коллекции не будет двух одинаковых элементов. При попытке добавить дублирующийся элемент, он не будет добавлен, и состояние `Set` останется неизменным.
- **Порядок элементов:** Базовый интерфейс `Set` не гарантирует сохранение порядка элементов. Однако есть реализации `Set`, такие как `LinkedHashSet` и `TreeSet`, которые предоставляют порядок следования элементов либо в порядке добавления, либо в упорядоченном виде.

### Основные реализации `Set`:

- **`HashSet`**: Это наиболее используемая реализация `Set`, которая использует хеш-таблицу для хранения элементов. `HashSet` предлагает хорошую производительность для основных операций, таких как добавление, удаление и поиск элементов. Однако он не гарантирует порядок элементов.

- **`LinkedHashSet`**: `LinkedHashSet` расширяет `HashSet` и добавляет связный список элементов, благодаря чему сохраняется порядок добавления элементов. Это сочетает преимущества хэш-таблицы с предсказуемым итерационным порядком.

- **`TreeSet`**: `TreeSet` реализует `Set` с использованием дерева. Элементы в `TreeSet` хранятся в отсортированном порядке. Это может быть полезно, когда необходим упорядоченный просмотр элементов. Однако операции добавления, удаления и поиска в `TreeSet` могут быть медленнее по сравнению с `HashSet` из-за затрат на поддержание упорядоченности.

### Использование `Set`:

```java
Set<String> set = new HashSet<>();
set.add("apple");
set.add("banana");
set.add("orange");

// Попытка добавить дублирующийся элемент не изменит набор
set.add("apple");

for (String fruit : set) {
    System.out.println(fruit);
}
```

Этот пример демонстрирует базовое использование `HashSet` для хранения уникальных строк. Порядок вывода элементов может быть не предсказуемым из-за особенностей `HashSet`.

### Заключение:

`Set` является ключевым интерфейсом в Java Collection Framework, предоставляющим мощные средства для работы с уникальными коллекциями объектов. Выбор конкретной реализации `Set` (такой как `HashSet`, `LinkedHashSet` или `TreeSet`) зависит от требований к вашему приложению, включая важность уникальности, порядка элементов и производительности операций.



В Java, интерфейсы `Comparable` и `Comparator` используются для сортировки коллекций объектов. В то время как оба интерфейса служат этой общей цели, они используются в различных сценариях и работают немного по-разному.

### Comparable

Интерфейс `Comparable` используется для определения естественного порядка сортировки объектов класса. Чтобы использовать этот интерфейс, класс должен реализовать метод `compareTo(T o)`, который сравнивает текущий объект с переданным объектом. Метод `compareTo()` возвращает:

- отрицательное целое число, если текущий объект меньше переданного объекта;
- ноль, если объекты равны;
- положительное целое число, если текущий объект больше переданного объекта.

Пример использования `Comparable`:

```java
public class Person implements Comparable<Person> {
    private String name;
    private int age;

    // Конструктор, геттеры и сеттеры

    @Override
    public int compareTo(Person anotherPerson) {
        return this.age - anotherPerson.age;
    }
}
```

Это позволяет сортировать массив или список объектов `Person` по возрасту, используя `Arrays.sort()` или `Collections.sort()` без необходимости указывать компаратор.

### Comparator

Интерфейс `Comparator` используется для определения порядка сортировки, который отличается от естественного порядка объектов. Это может быть полезно, когда вам нужно сортировать объекты по разным критериям или когда объекты класса, который вы сортируете, не реализуют `Comparable`.

`Comparator` определяется как отдельный класс или анонимный класс, и его можно передать в метод `sort()` в качестве параметра. Метод `compare(Object o1, Object o2)` в `Comparator` работает аналогично `compareTo()` в `Comparable`, сравнивая два объекта.

Пример использования `Comparator`:

```java
public class AgeComparator implements Comparator<Person> {
    @Override
    public int compare(Person p1, Person p2) {
        return p1.getAge() - p2.getAge();
    }
}

// Использование
Collections.sort(listOfPersons, new AgeComparator());
```

Также возможно использовать лямбда-выражения для создания компараторов на лету, например:

```java
Collections.sort(listOfPersons, (Person p1, Person p2) -> p1.getName().compareTo(p2.getName()));
```

### Вывод

Использование `Comparable` и `Comparator` зависит от сценария:

- `Comparable` применяется, когда нужен один естественный порядок сортировки объектов.
- `Comparator` идеален, когда нужно определить несколько различных способов сортировки или когда объекты сортируемого класса не реализуют `Comparable`.


### Коллекция `TreeSet`

`TreeSet` является одной из основных реализаций интерфейса `Set` в Java, предоставляемая Java Collection Framework. Как следует из названия, `TreeSet` основан на древовидной структуре, а именно на красно-черном дереве. Это обеспечивает упорядочение элементов в коллекции в соответствии с их естественным порядком или с помощью компаратора, предоставляемого при создании экземпляра `TreeSet`. Вот основные аспекты и характеристики `TreeSet`:

### Упорядоченность

- **Сортировка элементов**: `TreeSet` автоматически сортирует все элементы по возрастанию. Это упорядоченность обеспечивается либо естественным порядком элементов (если они реализуют интерфейс `Comparable`), либо с помощью `Comparator`, переданного в конструктор.
- **Уникальность элементов**: Как и любая реализация `Set`, `TreeSet` не допускает дублирование элементов. Элемент считается дубликатом, если он сравнивается как равный с другим элементом в наборе, согласно методу `compareTo` (для естественного упорядочения) или `compare` (для упорядочения с помощью `Comparator`).

### Производительность

- **Время выполнения операций**: Операции добавления, удаления и поиска элементов в `TreeSet` выполняются за логарифмическое время от числа элементов в наборе (`O(log(n))`), что делает `TreeSet` эффективным для больших объемов данных, где требуется быстрый поиск и упорядоченный перебор элементов.

### Основные методы

- **`add(E element)`**: Добавляет элемент в набор, если он уже не содержится в нем.
- **`remove(Object o)`**: Удаляет указанный элемент из набора, если он присутствует.
- **`contains(Object o)`**: Возвращает `true`, если набор содержит указанный элемент.
- **`first()`**: Возвращает первый (самый низкий) элемент из набора.
- **`last()`**: Возвращает последний (самый высокий) элемент из набора.
- **`headSet(E toElement)`**: Возвращает представление части набора, элементы которого строго меньше `toElement`.
- **`tailSet(E fromElement)`**: Возвращает представление части набора, элементы которого больше или равны `fromElement`.
- **`subSet(E fromElement, E toElement)`**: Возвращает представление части набора, элементы которого находятся в диапазоне `[fromElement, toElement)`.

### Использование

`TreeSet` идеально подходит для приложений, требующих упорядоченного хранения уникальных элементов, с быстрым доступом к наименьшему или наибольшему элементу, а также эффективным выполнением диапазонных запросов. Однако из-за затрат на поддержание упорядоченности и уникальности элементов с помощью древовидной структуры, `TreeSet` может быть менее эффективным по сравнению с другими реализациями `Set`, такими как `HashSet`, в случаях, когда упорядоченность элементов не требуется.

