### Lesson 33


### Структура данных "дерево"

Структура данных "дерево" представляет собой иерархическую структуру, имитирующую древовидную организацию, с одним корневым узлом на вершине и связанными подузлами, которые формируют поддеревья. Вот некоторые из основных терминов и понятий, связанных со структурой данных дерево:

1. **Узел (Node)**: Основная единица дерева, которая содержит данные или значение. Узел может иметь ссылку на один или несколько подузлов.

2. **Корень (Root)**: Верхний узел дерева, из которого происходят все остальные узлы. В любом дереве может быть только один корневой узел.

3. **Поддерево (Subtree)**: Любой узел дерева вместе со всеми его потомками образует поддерево.

4. **Родитель (Parent)**: Узел, имеющий один или несколько подузлов.

5. **Потомок (Child)**: Узел, являющийся подузлом другого узла. Узел может иметь несколько потомков.

6. **Лист (Leaf)**: Узел без потомков. Также известен как терминальный узел.

7. **Уровень (Level)**: Глубина узла, определяемая как количество ребер от корня до узла. Уровень корня обычно считается равным 0 или 1, в зависимости от конкретной номенклатуры.

8. **Высота (Height)**: Максимальное количество уровней в дереве. Высота дерева равна высоте его корневого узла.

9. **Глубина (Depth)**: Расстояние от корня до узла, определяемое количеством ребер на пути от корня к узлу.

10. **Степень (Degree)**: Количество подузлов (или потомков) узла. Узел с наибольшим количеством потомков имеет максимальную степень дерева.

11. **Бинарное дерево (Binary Tree)**: Специфический тип дерева, где каждый узел имеет не более двух потомков, известных как левый и правый потомок.

12. **Балансированное дерево (Balanced Tree)**: Дерево, в котором разница высот левого и правого поддеревьев для каждого узла не превышает определенного значения (обычно 1). Это обеспечивает оптимизацию времени поиска, вставки и удаления.

Эти термины образуют основу для понимания и работы с различными типами деревьев, включая бинарные деревья, бинарные деревья поиска, AVL-деревья, красно-черные деревья и многие другие.


### Структура данных "граф"

Структура данных "граф" представляет собой набор объектов, называемых вершинами (или узлами), которые могут быть соединены между собой ребрами. Графы могут использоваться для моделирования практически любых взаимосвязей и структур, например, сетей связи, карт дорог, и многого другого. Вот основные термины и понятия, связанные со структурой данных граф:

1. **Вершина (Vertex)**: Основная единица графа, представляющая собой объект или узел. Граф состоит из набора вершин.

2. **Ребро (Edge)**: Связь между парой вершин в графе. Ребра могут быть ориентированными (указывающими направление от одной вершины к другой) или неориентированными (без указания направления).

3. **Взвешенный граф (Weighted Graph)**: Граф, в котором каждому ребру присвоено определенное значение или вес, представляющее стоимость перехода между вершинами.

4. **Неориентированный граф (Undirected Graph)**: Граф, в котором ребра не имеют направления, то есть связь между вершинами двусторонняя.

5. **Ориентированный граф (Directed Graph)**: Граф, в котором каждое ребро имеет направление, указывающее от одной вершины к другой. Также известен как диграф.

6. **Смежные вершины (Adjacent Vertices)**: Вершины, соединенные ребром. В неориентированном графе обе вершины считаются смежными друг другу, в ориентированном — смежность учитывает направление ребра.

7. **Степень вершины (Degree of Vertex)**: Количество ребер, инцидентных вершине. В ориентированных графах различают входящую степень (количество ребер, входящих в вершину) и исходящую степень (количество ребер, выходящих из вершины).

8. **Путь (Path)**: Последовательность вершин, в которой каждая вершина (кроме последней) соединена ребром со следующей вершиной в последовательности.

9. **Цикл (Cycle)**: Путь, в котором начальная и конечная вершины совпадают, и при этом каждая вершина (кроме начальной/конечной) проходится один раз.

10. **Подграф (Subgraph)**: Граф, все вершины и ребра которого принадлежат другому графу.

11. **Связный граф (Connected Graph)**: Неориентированный граф, в котором существует путь между любой парой вершин. Для ориентированных графов аналогичное понятие — сильная связность.

12. **Дерево (Tree)**: Связный граф без циклов. Каждые две вершины соединены ровно одним путем.

13. **Ациклический направленный граф (DAG - Directed Acyclic Graph)**: Ориентированный граф без циклов. Часто используется для представления структур с зависимостями, где возможно четкое направление от предшественника к последователю.

Эти термины являются фундаментальными для понимания и работы с графами в различных областях, включая компьютерные науки, инженерию, биологию, и социальные науки.



### Коллекция TreeMap


Методы, полученные из интерфейсов SortedMap и NavigableMap

Как и HashMap, TreeMap реализует интерфейс Map, а это значит, что в TreeMap присутствуют все методы, которые есть в HashMap. Но, помимо этого, TreeMap реализует интерфейсы SortedMap и NavigableMap, добавляя дополнительный функционал.

**SortedMap** — интерфейс, который расширяет Map и добавляет методы для работы с отсортированным набором данных:

- **firstKey()**: возвращает ключ первого элемента мапы.
    - Комментарий: Полезно для получения самого маленького ключа в наборе.

- **lastKey()**: возвращает ключ последнего элемента.
    - Комментарий: Позволяет получить самый большой ключ в наборе.

- **headMap(K end)**: возвращает мапу, содержащую все элементы текущей мапы от начала до элемента с ключом end.
    - Комментарий: Удобно для создания поднабора элементов от начала до заданного ключа.

- **tailMap(K start)**: возвращает мапу, содержащую все элементы текущей мапы, начиная с элемента с ключом start и до конца.
    - Комментарий: Полезно для создания поднабора элементов от заданного ключа до конца мапы.

- **subMap(K start, K end)**: возвращает мапу, содержащую все элементы текущей мапы от ключа start до ключа end.
    - Комментарий: Используется для получения поднабора элементов между двумя ключами.

**NavigableMap** — интерфейс, который расширяет SortedMap и добавляет методы для навигации между элементами мапы:

- **firstEntry()**: возвращает первую пару “ключ-значение”.
    - Комментарий: Полезно для получения первой записи в мапе.

- **lastEntry()**: возвращает последнюю пару “ключ-значение”.
    - Комментарий: Позволяет получить последнюю запись в мапе.

- **pollFirstEntry()**: возвращает и удаляет первую пару.
    - Комментарий: Удобно для удаления и получения первой записи одновременно.

- **pollLastEntry()**: возвращает и удаляет последнюю пару.
    - Комментарий: Аналогично pollFirstEntry(), но для последней записи.

- **ceilingKey(K obj)**: возвращает наименьший ключ k, который больше или равен ключу obj. Если такого ключа нет, возвращает null.
    - Комментарий: Полезно для поиска ближайшего большего или равного ключа.

- **floorKey(K obj)**: возвращает самый большой ключ k, который меньше или равен ключу obj. Если такого ключа нет, возвращает null.
    - Комментарий: Используется для поиска ближайшего меньшего или равного ключа.

- **lowerKey(K obj)**: возвращает наибольший ключ k, который меньше ключа obj. Если такого ключа нет, возвращает null.
    - Комментарий: Полезно для поиска ближайшего меньшего ключа.

- **higherKey(K obj)**: возвращает наименьший ключ k, который больше ключа obj. Если такого ключа нет, возвращает null.
    - Комментарий: Используется для поиска ближайшего большего ключа.

- **ceilingEntry(K obj)**: аналогичен методу ceilingKey(K obj), но возвращает пару “ключ-значение” (или null).
    - Комментарий: Полезно для получения ближайшей большего или равного ключа пары.

- **floorEntry(K obj)**: аналогичен методу floorKey(K obj), но возвращает пару “ключ-значение” (или null).
    - Комментарий: Используется для получения ближайшей меньшего или равного ключа пары.

- **lowerEntry(K obj)**: аналогичен методу lowerKey(K obj), но возвращает пару “ключ-значение” (или null).
    - Комментарий: Полезно для получения ближайшей меньшего ключа пары.

- **higherEntry(K obj)**: аналогичен методу higherKey(K obj), но возвращает пару “ключ-значение” (или null).
    - Комментарий: Используется для получения ближайшей большего ключа пары.

- **descendingKeySet()**: возвращает NavigableSet, содержащий все ключи, отсортированные в обратном порядке.
    - Комментарий: Удобно для получения набора ключей в обратном порядке.

- **descendingMap()**: возвращает NavigableMap, содержащую все пары, отсортированные в обратном порядке.
    - Комментарий: Полезно для получения мапы, отсортированной в обратном порядке.

- **navigableKeySet()**: возвращает объект NavigableSet, содержащий все ключи в порядке хранения.
    - Комментарий: Удобно для получения набора ключей в порядке их хранения.

- **headMap(K upperBound, boolean incl)**: возвращает мапу, содержащую пары от начала и до элемента upperBound. Аргумент incl указывает, нужно ли включать элемент upperBound в возвращаемую мапу.
    - Комментарий: Полезно для создания поднабора с возможностью включения или исключения граничного элемента.

- **tailMap(K lowerBound, boolean incl)**: аналогично предыдущему методу, но возвращает пары от lowerBound и до конца.
    - Комментарий: Удобно для создания поднабора от заданного ключа с возможностью включения или исключения начального элемента.

- **subMap(K lowerBound, boolean lowIncl, K upperBound, boolean highIncl)**: возвращает пары от lowerBound и до upperBound. Аргументы lowIncl и highIncl указывают, включать ли граничные элементы в новую мапу.
    - Комментарий: Полезно для создания поднабора с возможностью управления включением граничных элементов.

В самой реализации TreeMap, помимо привычных конструкторов, добавляется конструктор, принимающий экземпляр компаратора. Этот компаратор отвечает за порядок хранения элементов.
- Комментарий: Это позволяет задавать пользовательскую логику сортировки элементов в TreeMap.