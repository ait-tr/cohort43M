### Lesson 32


В Java, `enum` (или перечисление) используется для определения коллекции именованных констант.
Эти константы могут быть примитивными значениями или комплексными объектами. Использование `enum`
в Java помогает сделать код более читаемым и безопасным, поскольку оно ограничивает возможные значения
переменной до предопределённого набора.

### Основы использования `enum` в Java

Перечисления объявляются с использованием ключевого слова `enum`, за которым следует имя перечисления.
Вот простой пример `enum`, который представляет дни недели:

```java
public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
}
```

### Пример использования `enum`

```java
public class TestEnum {
    Day day;

    public TestEnum(Day day) {
        this.day = day;
    }

    public void tellItLikeItIs() {
        switch (day) {
            case MONDAY:
                System.out.println("Mondays are bad.");
                break;
            case FRIDAY:
                System.out.println("Fridays are better.");
                break;
            case SATURDAY: case SUNDAY:
                System.out.println("Weekends are best.");
                break;
            default:
                System.out.println("Midweek days are so-so.");
                break;
        }
    }

    public static void main(String[] args) {
        TestEnum firstDay = new TestEnum(Day.MONDAY);
        firstDay.tellItLikeItIs();
        TestEnum thirdDay = new TestEnum(Day.WEDNESDAY);
        thirdDay.tellItLikeItIs();
        TestEnum fifthDay = new TestEnum(Day.FRIDAY);
        fifthDay.tellItLikeItIs();
        TestEnum sixthDay = new TestEnum(Day.SATURDAY);
        sixthDay.tellItLikeItIs();
        TestEnum seventhDay = new TestEnum(Day.SUNDAY);
        seventhDay.tellItLikeItIs();
    }
}
```

В этом примере `enum Day` используется для управления поведением
метода `tellItLikeItIs` на основе дня недели. Это демонстрирует, как `enum`
может быть использован в `switch`-выражениях.

### Продвинутое использование `enum`

`enum` в Java может иметь поля, методы и конструкторы, как показано ниже:

```java
public enum Season {
    WINTER("Cold"), SPRING("Warm"), SUMMER("Hot"), FALL("Cool");

    private final String description;

    private Season(String description) {
        this.description = description;
    }

    public String getDescription() {
        return this.description;
    }
}

public class TestSeason {
    public static void main(String[] args) {
        for (Season season : Season.values()) {
            System.out.println(season + " is " + season.getDescription() + ".");
        }
    }
}
```

В этом примере `Season` - это `enum`, который не только содержит перечисление времён года,
но и связанное с каждым из них описание. Каждый элемент `enum` может иметь свои уникальные
поля и методы, что делает `enum` в Java очень мощным инструментом для создания высокоуровневых абстракций.

### Заключение

Использование `enum` в Java предоставляет мощный механизм для определения групп фиксированных
констант, что может улучшить читаемость кода, обеспечить безопасность типов и упростить
реализацию определённых конструкций программирования, таких как свитчи или конечные автоматы.
Благодаря возможности добавления полей, методов и конструкторов, `enum` предлагает гибкость
в определении сложных типов данных.

### Коллекции. Stack


В Java, `Stack` является классом, который расширяет класс `Vector` и реализует традиционную структуру данных стека в виде объекта, позволяя элементам быть добавленными и удаленными по принципу "последним пришел — первым ушел" (LIFO - Last In, First Out).
Однако стоит отметить, что класс `Stack` считается устаревшим (legacy) и его использование в новом коде не рекомендуется.
Вместо этого предпочтительнее использовать интерфейс `Deque` и его реализации, такие как `ArrayDeque`, для работы со стеком, поскольку они обеспечивают более комплексную и гибкую структуру данных.

Вот основные методы класса `Stack`:


1. **`boolean empty()`**
    - Проверяет, пуст ли стек.
    - Возвращает `true`, если стек пуст, и `false` в противном случае.

2. **`E peek()`**
    - Возвращает элемент на вершине стека, не удаляя его.
    - Выбрасывает `EmptyStackException`, если стек пуст.

3. **`E pop()`**
    - Удаляет и возвращает элемент на вершине стека.
    - Выбрасывает `EmptyStackException`, если стек пуст.

4. **`E push(E item)`**
    - Добавляет элемент на вершину стека.
    - Возвращает добавленный элемент.
    - Параметр `item` — элемент, который необходимо добавить на стек.

5. **`int search(Object o)`**
    - Осуществляет поиск объекта `o` в стеке и возвращает его позицию от вершины стека.
    - Возвращает `1`-based позицию элемента, если элемент найден, или `-1`, если элемент в стеке отсутствует.

Эти методы предоставляют базовый функционал для работы со стеком, позволяя легко добавлять, удалять и просматривать элементы. Несмотря на то что класс `Stack` является частью оригинальной Java 1.0, для нового кода рекомендуется использовать более современные и гибкие структуры данных, такие как `ArrayDeque`.

###  Основные методы интерфейса `Queue`:

Коллекция `Queue` в Java представляет собой интерфейс в Java Collection Framework, который расположен в пакете `java.util`. Он предназначен для работы с коллекциями, организованными по принципу FIFO (First-In-First-Out), то есть первым пришел — первым ушел. Однако некоторые реализации `Queue` могут предоставлять другой порядок обработки элементов, например, приоритетные очереди.


- **add(e)**: Добавляет элемент `e` в конец очереди. Возвращает `true`, если элемент был успешно добавлен. Если очередь не может добавить новый элемент из-за ограничений емкости, этот метод генерирует исключение `IllegalStateException`.
- **offer(e)**: Пытается добавить элемент `e` в очередь. Возвращает `true`, если элемент был успешно добавлен, и `false`, если очередь не смогла добавить элемент из-за ограничений емкости. Этот метод предпочтителен для очередей с ограниченной емкостью, поскольку он не генерирует исключения.
- **remove()**: Удаляет и возвращает головной элемент очереди. Если очередь пуста, генерируется исключение `NoSuchElementException`.
- **poll()**: Удаляет и возвращает головной элемент очереди, или возвращает `null`, если очередь пуста. Этот метод предпочтителен в ситуациях, когда неизвестно, пуста ли очередь.
- **element()**: Возвращает, но не удаляет головной элемент очереди. Если очередь пуста, генерируется исключение `NoSuchElementException`.
- **peek()**: Возвращает, но не удаляет головной элемент очереди, или возвращает `null`, если очередь пуста. Этот метод используется для просмотра элемента на вершине очереди без его удаления.

Различные реализации интерфейса `Queue` обеспечивают разное поведение для этих операций. Например, `LinkedList` и `PriorityQueue` являются двумя общеизвестными реализациями. `LinkedList` предоставляет общую реализацию очереди, обрабатывающую элементы в порядке их добавления, в то время как `PriorityQueue` управляет элементами согласно их приоритетам, а не порядку добавления.

Очереди часто используются в программировании для организации последовательной обработки объектов, таких как задания печати, операции в многопоточных или сетевых приложениях, где требуется обрабатывать запросы в порядке их поступления или с определенным приоритетом.


### Основные методы интерфейса `Deque`:

В Java, `Deque` (двусторонняя очередь) — это интерфейс в стандартной библиотеке коллекций, который расширяет интерфейс `Queue`.
Он поддерживает вставку и удаление элементов с обеих сторон.
Это позволяет использовать объекты, реализующие `Deque`, как стандартные очереди FIFO (первым пришел — первым ушел), так и стеки LIFO (последним пришел — первым ушел).


- **Добавление элементов**:
    - `addFirst(E e)`: добавляет элемент в начало очереди.
    - `addLast(E e)`: добавляет элемент в конец очереди.
    - `offerFirst(E e)`: добавляет элемент в начало очереди; возвращает `true`, если элемент был успешно добавлен, иначе `false`.
    - `offerLast(E e)`: добавляет элемент в конец очереди; аналогичен `offerFirst(E e)`, но для конца очереди.

- **Удаление элементов**:
    - `removeFirst()`: удаляет и возвращает первый элемент очереди. Выбрасывает исключение `NoSuchElementException`, если очередь пуста.
    - `removeLast()`: удаляет и возвращает последний элемент очереди. Аналогичен `removeFirst()`, но для последнего элемента.
    - `pollFirst()`: удаляет и возвращает первый элемент очереди или возвращает `null`, если очередь пуста.
    - `pollLast()`: аналогичен `pollFirst()`, но для последнего элемента.

- **Получение элементов (без удаления)**:
    - `getFirst()`: возвращает первый элемент очереди без его удаления. Выбрасывает `NoSuchElementException`, если очередь пуста.
    - `getLast()`: возвращает последний элемент очереди без его удаления. Аналогичен `getFirst()`, но для последнего элемента.
    - `peekFirst()`: возвращает первый элемент очереди без его удаления или `null`, если очередь пуста.
    - `peekLast()`: аналогичен `peekFirst()`, но для последнего элемента.

- **Прочие методы**:
    - `isEmpty()`: возвращает `true`, если очередь пуста.
    - `size()`: возвращает количество элементов в очереди.
    - `clear()`: удаляет все элементы из очереди.
    - `contains(Object o)`: возвращает `true`, если очередь содержит указанный элемент.

Эти методы обеспечивают гибкость в работе с двусторонними очередями, позволяя использовать их как для стандартных очередей, так и для стеков.
Реализации `Deque` включают классы `ArrayDeque` и `LinkedList`.
`ArrayDeque` обычно быстрее `LinkedList` для большинства операций, кроме тех, которые включают вставку или удаление элементов в середине коллекции.

