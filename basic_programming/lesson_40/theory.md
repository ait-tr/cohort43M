### Lesson 40


Стандартные функциональные интерфейсы в Java – это предопределенные интерфейсы, введенные в Java 8, которые предоставляют простой способ реализации функциональных интерфейсов с использованием лямбда-выражений и методов ссылок. Функциональный интерфейс – это интерфейс, содержащий только один абстрактный метод, и, таким образом, представляющий одну функцию или действие. Стандартные функциональные интерфейсы позволяют разработчикам писать более краткий и выразительный код, особенно когда речь идет о создании анонимных классов.

В Java 8 и более поздних версиях в пакете `java.util.function` представлены различные стандартные функциональные интерфейсы. Вот некоторые из самых используемых:

1. **`Function<T,R>`**: Принимает объект типа T и возвращает объект типа R. Метод по умолчанию – `apply(T t)`.

2. **`Predicate<T>`**: Принимает объект типа T и возвращает логическое значение (`true` или `false`). Метод по умолчанию – `test(T t)`.

3. **`Consumer<T>`**: Принимает объект типа T и не возвращает значение. Метод по умолчанию – `accept(T t)`.

4. **`Supplier<T>`**: Не принимает никаких аргументов, но возвращает объект типа T. Метод по умолчанию – `get()`.

5. **`UnaryOperator<T>`**: Расширяет `Function<T,R>`, где входной и выходной типы совпадают. Используется для операций, где входной и выходной объекты имеют один и тот же тип.

6. **`BinaryOperator<T>`**: Также расширяет `Function<T,R>`, но принимает два аргумента одного типа и возвращает результат того же типа. Используется для операций, которые принимают два аргумента и возвращают один результат того же типа.

Эти интерфейсы могут использоваться для создания лямбда-выражений, ссылок на методы и конструкторы в различных сценариях, таких как работа со стримами, коллекциями и выполнение операций высшего порядка.


### Метод референс

Метод референс (Method Reference) в Java — это способ ссылаться на метод без его выполнения. Введенный в Java 8, метод референс упрощает запись, когда вы хотите передать ссылку на метод или конструктор в качестве аргумента функционального интерфейса. Это одна из возможностей, которая способствует функциональному программированию в Java, позволяя писать более краткий и читаемый код.

### Виды метод референсов

1. **Ссылка на статический метод** - Используется для ссылки на статический метод класса.
    - Синтаксис: `Класс::статическийМетод`
    - Пример: `String::valueOf` преобразует объект в строку через статический метод `valueOf` класса `String`.

2. **Ссылка на метод экземпляра конкретного объекта** - Используется, когда метод вызывается на конкретном объекте.
    - Синтаксис: `инстанс::методЭкземпляра`
    - Пример: `System.out::println` вызывает метод `println` на конкретном объекте `System.out`.

3. **Ссылка на метод экземпляра произвольного объекта из определенного типа** - Используется для вызова метода на объекте, который является параметром метода.
    - Синтаксис: `Класс::методЭкземпляра`
    - Пример: `String::toLowerCase` вызывает метод `toLowerCase` на объекте типа `String`, который будет передан.

4. **Ссылка на конструктор** - Используется для ссылки на конструктор.
    - Синтаксис: `Класс::new`
    - Пример: `ArrayList::new` создает новый объект `ArrayList` с помощью конструктора.

### Пример использования

Допустим, у нас есть список строк, и мы хотим отсортировать его в лексикографическом порядке без учета регистра. Вместо того чтобы использовать анонимный класс или лямбда-выражение, мы можем использовать метод референс.

```java
List<String> words = Arrays.asList("Apple", "Banana", "Cherry", "Date");

// Использование лямбда-выражения
words.sort((s1, s2) -> s1.compareToIgnoreCase(s2));

// Использование метод референса
words.sort(String::compareToIgnoreCase);
```

Оба варианта кода делают одно и то же, но использование метод референса делает код более лаконичным и легким для чтения.




### `StringBuffer` и `StringBuilder`

В Java `StringBuffer` и `StringBuilder` классы используются для создания изменяемых (modifiable) последовательностей символов. Основные различия между этими двумя классами заключаются в следующем:

1. **Синхронизация**:
    - `StringBuffer` является потокобезопасным (thread-safe), что означает, что все методы `StringBuffer` синхронизированы для использования в многопоточных средах. Потокобезопасность гарантирует, что только один поток может выполнять метод в данное время.
    - `StringBuilder` не является потокобезопасным. Это делает его более быстрым по сравнению с `StringBuffer`, поскольку отсутствие синхронизации снижает накладные расходы.

2. **Скорость**:
    - Из-за потокобезопасности и синхронизации, `StringBuffer` работает медленнее по сравнению с `StringBuilder`.
    - `StringBuilder` предпочтительнее для использования в однопоточных средах, где требуется высокая производительность, так как он быстрее из-за отсутствия синхронизации.

3. **Использование**:
    - `StringBuffer` следует использовать, когда есть необходимость в потокобезопасной операции со строками в многопоточной среде.
    - `StringBuilder` лучше подходит для использования в сценариях, когда выполняется работа с изменяемыми последовательностями символов в однопоточной среде.

В обоих классах предоставляются похожие методы для изменения содержимого строки, такие как `append()`, `insert()`, `delete()` и так далее.
Выбор между `StringBuffer` и `StringBuilder` зависит от конкретных требований к приложению и среде его выполнения.


